
'''
Author: Guilherme Marino Toso
Title = glm
Project: Semi-Supervised Learning Using Competition for Neurons' Synchronization
Package = neurons

Discription:
   A Neural Dynamical System is a set of differential equations that discribes
   the time evolution of the differential equations' variables as the action
   potential generated by a neuron and which is a variable in common with all
   the models. The model presented here is quite different, it is a linear
   diffential equation called Generalized Linear Model. This model, dispite
   the others were not studied at the graduation project called "Análise de Sincronização 
   em Modelos de Osciladores Acoplados". 

'''
import numpy as np
from .core import negative_refractory, iaf_refractory, threshold_refractory
from .core import mean_lifetime, delay_response, gamma_response
from .core import moto_response, alpha_response, linear, senoidal, exponential
from .core import rate_constant, fire_probability, survivor, interval_dist
import inspect


class Kernel():

    """ 
    ..py:class:: 
    
    This is the Kernel Class. It provides kernels for the Generalized Linear Model assembly.
    
    ..py:function:: __init__(self,*args,**kwargs)

    :param refractory_dic: A dictionary data structure that contains the refractory kernels
    :type refractory_dic: dict
    :param response_dic: A dictionary data structure that contains the response kernels
    :type response_dic: dict
    :param current_dic: A dictionary data structure that contains the current kernels
    :type current_dic: dict
    :param rate_dic: A dictionary data structure that contains the rate kernels
    :type rate_dic: dict
    :param fire_dic: A dictionary data structure that contains the fire kernels
    :type fire_dic: dict
    :param surviving_dic: A dictionary data structure that contains the surviving kernels
    :type surviving_dic: dict
    :param interval_dic: A dictionary data structure that contains the interval kernels
    :type interval_dic: dict
    
    """


    def __init__(self,*args,**kwargs):
        super().__init__()
        self.refractory_dic = {
            'negative':negative_refractory,
            'iaf':iaf_refractory,
            'threshold':threshold_refractory}
        self.response_dic = {
            'lifetime':mean_lifetime,
            'delay':delay_response,
            'gauss_delay':normal_delay_response,
            'gamma':gamma_response,
            'motoneuron':moto_response,
            'alpha':alpha_response
        }
        self.current_dic = {
            'linear':linear,
            'senoidal':senoidal,
            'exponential':exponential
        }
        self.rate_dic = {
            'constant':rate_constant
        }
        self.fire_dic = {
            'fire':fire_probability
        }
        self.surviving_dic = {
            'survivor':survivor
        }
        self.interval_dic = {
            'int_dist':interval_dist
        }


class GLM(Kernel):

    """ 
    .. py:class::
    
    This is the GLM class which stands for Generalized Linear Model.
    
    .. py:function:: __init__(self,*args,**kwargs)

    :param adjacency: The adjacency matrix of neurons connections (1 - connected, 0 - non-connected) given by Keyword: 'adjacency'
    :type adjacency: numpy.ndarray
    :param current_kernel: The eletrical external current kernel given by Keyword: 'current'
    :type current_kernel: Kernel.current_kernel
    :param current: Same as current_kernel
    :type current: Kernel.current_kernel
    :param delay: time of delay for the electrical current insertion given by keyword 'delay'.
    :type delay: int, float or numpy.ndarray
    :param fire: threshold for happening the neural fire given by keyword 'fire'
    :type fire: float or numpy.ndarray.
    :param fire_beta: Noise measurement $\beta$ given by the keyword 'fire_beta'
    :type fire_beta: int, float or numpy.ndarray
    :param fire_tau:  Growth parameter $\tau$
    :type fire_tau: int, float or numpy.ndarray
    :param neurons: The amount of neurons or samples.
    :type neurons: int
    :param potential: The membrane potential at time t
    :type potential: numpy.ndarray
    :param refractory_kernel: The refractory kernel chosen given by the keyword 'refractory'
    :type refractory_kernel: Kernel.refractory_kernel
    :param refractory: Same as refractory_kernel
    :type refractory: Kernel.refractory_kernel
    :param response_kernel: The response kernel chosen given by the keyword 'response'
    :type response_kernel: Kernel.response_kernel
    :param response: Same as response_kernel
    :type response: Kernel.response_kernel
    :param spiketrain: The Neural activity in time
    :type spiketrain: numpy.ndarray
    :param step: time step
    :type step: int or float
    :param theta_amp: the amplitude of the firing threshold raise
    :type theta_amp: int or float
    :param threshold: limit where occurs a neuron's fire
    :type threshold: int or float
    :param weights: The neurons' interconnections weights
    :type weights: numpy.ndarray
    :param window: The window size in time structure to store data
    :type window: int
    
    """
    
    def __init__(self, *args, **kwargs):

        super().__init__()
        self.adjacency = kwargs.get("adjacency")
        self.current_kernel = self.current_dic[kwargs.get('current')]
        self.current = self.current_kernel
        self.delay = kwargs.get('delay')
        self.fire = kwargs.get('fire')
        self.fire_beta = kwargs.get("fire_beta")
        self.fire_tau = kwargs.get("fire_tau")
        self.neurons = kwargs.get('neurons')
        self.potential = None
        self.refractory_kernel = self.refractory_dic[kwargs.get('refractory')]
        self.refractory = self.refractory_kernel
        self.response_kernel = self.response_dic[kwargs.get('response')]
        self.response = self.response_kernel
        self.spiketrain = kwargs.get("spiketrain")
        self.step = kwargs.get("step")
        self.theta_amp = kwargs.get("theta_amp")
        self.threshold = kwargs.get('threshold')
        self.weights = kwargs.get("weights")
        self.window = kwargs.get("window")
        
        if isinstance(self.spiketrain,np.ndarray):
            self.arrival = self.spiketrain[0,:]
            self.last_spike = np.argmax(self.spiketrain[::-1,:],axis=0)
        else:
            self.last_spike = None
            self.arrival = None
        if isinstance(self.neurons,int):            
            self.eps_matrix = np.zeros((1,self.neurons))
            self.data = np.random.uniform(-72,-68,size=(1,self.neurons))
            self.rest_potential = self.data
            if isinstance(self.threshold,(int,float)):
                self.theta = np.zeros(shape=(1,self.neurons))-self.threshold
            else:
                self.theta = None
        else:
            self.eps_matrix = None
            self.data = None
            self.rest_potential = None
            self.theta = None

    def set_parameters(self,**kwargs):

        """ 
        ..py::function:

        This function set the class attributes using the keywords.
        
        """

        for key, value in kwargs.items():
            setattr(self,key,value)
        self.__init__()


    def external_current(self,*args,initializer=0):

        """ 
        .. py::function:

        This function calculates the external current at the time t

        :param *args: The arguments that are passed to the current kernel
        :type *args: int, float or numpy.ndarray
        :param initializer: The current value when the time of the last spike is below the delay time. Default is zero.
        :type initializer: int, float, numpy.ndarray
        
        """

        self.I = np.where(self.last_spike>self.delay,self.current(*args),initializer)
        
    def incoming_spikes(self,*args):

        """ 
        .. py::function:

        This function calculates the incoming spikes for all the neurons at time t.

        :param *args: The response kernel arguments
        :type *args: int, float or numpy.ndarray
        
        """
        
        self.activities = self.adjacency*self.arrival[:,np.newaxis]
        self.connections = self.activities*self.weights
        self.contribution = np.sum(self.connections,axis=0)
        self.epsilon = self.response(*args)
        self.influence = self.contribution*self.epsilon
        self.eps_matrix = np.vstack((self.eps_matrix,self.influence))
        self.incoming = np.sum(self.eps_matrix,axis=0)
      
    def membrane_potential(self,*args):

        """ 
        .. py::function:

        This function calculates the membrane potential at time t.

        :params *args: The refractory kernel arguments
        :type *args: int, float or numpy.ndarray

        """

        self.potential = self.refractory(*args) + self.incoming + self.rest_potential + self.I

    def generate_spikes(self):

        """ 
        .. py::function:

        This function generates the spikes based on the potential and the fire probability
        
        """

        self.probabilities = rate_constant(self.potential, self.theta, self.fire_beta, self.fire_tau)
        self.spikes = np.where(self.probabilities>=np.random.uniform(self.fire,1),1,0)
        self.spiketrain = np.vstack((self.spiketrain,self.spikes))
    
    def update(self):

        """ 
        .. py::function:

        This function updates the spiketrain, last_spike time, theta value, data, response matrix 
        and the new arrival spikes vector.        
        
        """

        self.spiketrain = self.spiketrain[max(0,self.spiketrain.shape[0]-self.window):,:]
        self.last_spike = np.argmax(self.spiketrain[::-1,:],axis=0)*self.step
        self.theta = self.threshold + self.theta_amp*np.exp(-self.last_spike)
        self.data = np.vstack((self.data, self.potential))
        self.data = self.data[max(0,self.data.shape[0]-self.window):,:]
        self.eps_matrix = self.eps_matrix[max(0,self.eps_matrix.shape[0]-self.window):,:]
        self.arrival = self.spikes